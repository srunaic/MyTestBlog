name: Cleanup Deployments

on:
  workflow_dispatch:
    inputs:
      dry_run:
        description: 'Dry Run (Check logs without deleting)'
        required: true
        default: false
        type: boolean
      keep_count:
        description: 'Number of recent deployments to KEEP (Default: 5)'
        required: true
        default: '5'
        type: number
      delete_limit:
        description: 'Max deployments to DELETE in this run (Default: 50)'
        required: true
        default: '50'
        type: number

permissions:
  deployments: write
  contents: read

jobs:
  cleanup:
    runs-on: ubuntu-latest
    steps:
      - name: Cleanup Old Deployments
        uses: actions/github-script@v6
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const dryRun = ${{ inputs.dry_run }};
            const keepCount = ${{ inputs.keep_count }};
            const deleteLimit = ${{ inputs.delete_limit }};

            console.log(`Starting cleanup for ${owner}/${repo}`);
            console.log(`Config: Dry Run=${dryRun}, Keep=${keepCount}, Delete Limit=${deleteLimit}`);

            // Fetch all deployments
            let allDeployments = [];
            let page = 1;
            while (true) {
                const { data } = await github.rest.repos.listDeployments({
                    owner,
                    repo,
                    per_page: 100,
                    page: page,
                    environment: 'github-pages'
                });
                if (data.length === 0) break;
                allDeployments = allDeployments.concat(data);
                page++;
                // Safety break
                if (page > 50) break; 
            }

            console.log(`Found total ${allDeployments.length} deployments.`);

            if (allDeployments.length <= keepCount) {
                console.log(`Total deployments (${allDeployments.length}) is less than or equal to keep count (${keepCount}). Intentionally skipping.`);
                return;
            }

            // Sort by ID descending (newest first)
            allDeployments.sort((a, b) => b.id - a.id);

            // Determine targets
            const keptDeployments = allDeployments.slice(0, keepCount);
            const candidates = allDeployments.slice(keepCount);
            const toDelete = candidates.slice(0, deleteLimit);

            console.log(`- Keeping newest ${keptDeployments.length} deployments.`);
            console.log(`- Candidates for deletion: ${candidates.length}`);
            console.log(`- Targeting first ${toDelete.length} of those candidates (due to limit ${deleteLimit}).`);

            let deletedCount = 0;
            let errorCount = 0;

            for (const dep of toDelete) {
                if (dryRun) {
                    console.log(`[DRY-RUN] Would delete deployment ID ${dep.id} (${dep.created_at})`);
                    continue;
                }

                try {
                    // 1. Mark as inactive first (Required for active deployments)
                    try {
                        await github.rest.repos.createDeploymentStatus({
                            owner,
                            repo,
                            deployment_id: dep.id,
                            state: 'inactive'
                        });
                        // console.log(`[STATUS] Marked ID ${dep.id} as inactive`);
                    } catch (statErr) {
                        // Ignore if it fails (e.g. already inactive)
                    }

                    // 2. Delete
                    await github.rest.repos.deleteDeployment({
                        owner,
                        repo,
                        deployment_id: dep.id
                    });
                    console.log(`[DELETED] Deployment ID ${dep.id}`);
                    deletedCount++;
                    
                    // Rate limit friendly pause
                    await new Promise(r => setTimeout(r, 200));
                } catch (err) {
                    console.error(`[ERROR] Failed to delete ID ${dep.id}: ${err.message}`);
                    errorCount++;
                }
            }

            console.log(`Job Complete. Deleted: ${deletedCount}, Errors: ${errorCount}, Remaining Total: ${allDeployments.length - deletedCount}`);
