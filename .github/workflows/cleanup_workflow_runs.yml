name: Cleanup Workflow Runs

on:
  workflow_dispatch:
    inputs:
      dry_run:
        description: 'Dry Run (Check logs without deleting)'
        required: true
        default: false
        type: boolean
      keep_count:
        description: 'Number of recent runs to KEEP per workflow (Default: 5)'
        required: true
        default: '5'
        type: number
      delete_limit:
        description: 'Max runs to DELETE in this run (Default: 100)'
        required: true
        default: '100'
        type: number

permissions:
  actions: write
  contents: read

jobs:
  cleanup-runs:
    runs-on: ubuntu-latest
    steps:
      - name: Cleanup Old Workflow Runs
        uses: actions/github-script@v6
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const dryRun = ${{ inputs.dry_run }};
            const keepCount = ${{ inputs.keep_count }}; // Keep N per workflow
            const deleteLimit = ${{ inputs.delete_limit }}; // Hard cap on total deletions

            console.log(`Starting run cleanup for ${owner}/${repo}`);
            console.log(`Config: Dry Run=${dryRun}, Keep=${keepCount}, Delete Limit=${deleteLimit}`);

            // 1. Fetch all workflow runs
            // We'll fetch a decent number to find old ones.
            // Note: API returns mixed workflows. We should group by workflow_id or name to respect "keep per workflow"
            // But simple approach: Keep global latest N or per workflow?
            // "keep_count" usually implies "keep last N of EACH workflow type" or "last N global"?
            // Let's implement global "List all runs" and keep the absolute newest N for simplicity, 
            // OR group by workflow_id if possible. 
            // The user wants to clean up "history". 
            // A safer approach is to group by 'workflow_id'.
            
            // Let's just fetch all runs first.
            let allRuns = [];
            let page = 1;
            // Fetch up to 500 runs to process
            while (true) {
                const { data } = await github.rest.actions.listWorkflowRunsForRepo({
                    owner,
                    repo,
                    per_page: 100,
                    page: page
                });
                if (data.workflow_runs.length === 0) break;
                allRuns = allRuns.concat(data.workflow_runs);
                page++;
                if (page > 10) break; // Fetch max 1000
            }

            console.log(`Found total ${allRuns.length} workflow runs.`);

            // Group by workflow_id to ensure we keep at least N for EACH workflow
            const runsByWorkflow = {};
            for (const run of allRuns) {
                if (!runsByWorkflow[run.workflow_id]) {
                    runsByWorkflow[run.workflow_id] = [];
                }
                runsByWorkflow[run.workflow_id].push(run);
            }

            let toDelete = [];

            for (const [wfId, runs] of Object.entries(runsByWorkflow)) {
                // Sort descending by ID (newest first)
                runs.sort((a, b) => b.id - a.id);
                
                // Keep first N
                if (runs.length > keepCount) {
                    const removable = runs.slice(keepCount);
                    toDelete = toDelete.concat(removable);
                }
            }

            // Global limit application
            // Sort toDelete by ID just in case, though usually we delete oldest.
            // Let's delete OLDEST first? Or just obey the limit.
            // If we have 500 to delete but limit is 100, we should delete the 100 OLDEST ones ideally, 
            // or just the first 100 we found.
            // Let's sort `toDelete` by ID ASCENDING (Oldest first) so we clean up the tail.
            toDelete.sort((a, b) => a.id - b.id);
            
            if (toDelete.length > deleteLimit) {
                console.log(`Total candidates ${toDelete.length} exceeds limit ${deleteLimit}. Trimming to limit.`);
                toDelete = toDelete.slice(0, deleteLimit);
            }

            console.log(`Final count to delete: ${toDelete.length}`);

            let deletedCount = 0;
            for (const run of toDelete) {
                if (dryRun) {
                    console.log(`[DRY-RUN] Will delete Run ID ${run.id} (${run.name} - ${run.created_at})`);
                    continue;
                }

                try {
                    await github.rest.actions.deleteWorkflowRun({
                        owner,
                        repo,
                        run_id: run.id
                    });
                    console.log(`[DELETED] Run ID ${run.id} (${run.name})`);
                    deletedCount++;
                } catch (err) {
                    console.error(`[ERROR] Failed to delete run ${run.id}: ${err.message}`);
                }
            }

            console.log(`Done. Deleted ${deletedCount} runs.`);
